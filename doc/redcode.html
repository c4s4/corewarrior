<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<title>Core Warrior : Red Code</title>
</head>

<body bgcolor="#000000" text="#FFCC00" link="#FF0000" vlink="#FFCC00">
<font color="#FF0000"><h1>Le langage Red Code</h1></font>

<p>
Le langage Red Code permet de programmer les adversaires qui vont s'affronter dans la m&eacute;moire de l'ordinateur. Il est tr&egrave;s simple et proche d'un langage d'assemblage (il ressemble beaucoup &agrave; l'assembleur des microprocesseurs de la famille x86 d'Intel).

<p>
La m&eacute;moire de l'ordinateur est constitu&eacute;e de 4096 cases (8000 dans la version originale de Dewdney, ce nombre a &eacute;t&eacute; diminu&eacute; pour une raison expliqu&eacute;e par la suite). La m&eacute;moire est "boucl&eacute;e" : la case apr&egrave;s la derni&egrave;re (d'adresse 4095) est la premi&egrave;re case (d'adresse 0). Ainsi, l'adresse 4100 est &eacute;quivalente &agrave; l'adresse 4 (4100 - 4096 = 4) et -3 est &eacute;quivalente &agrave; 4093.

<p>
Trois m&eacute;thodes d'adressage de la m&eacute;moire sont possibles dans une instruction :

<ol>
<li><font color="#FF0000">Relatif</font> : C'est le mode par d&eacute;faut. Il est relatif &agrave; la case de l'instruction en cours d'ex&eacute;cution. Par exemple, 3 pointe vers la troisi&egrave;me case apr&egrave;s la case de l'instruction en cours d'ex&eacute;cution.

<li><font color="#FF0000">Indirect</font> : Est indiqu&eacute; par un signe <font color="#FF0000">@</font>. L'adresse apr&egrave;s le signe @ n'est pas l'adresse point&eacute;e mais l'adresse de l'adresse point&eacute;e. Par exemple @3 pointe vers la case dont l'adresse est 3 cases apr&egrave;s celle de l'instruction en cours. Attention, la case contenant l'adresse doit etre du type DAT (cf plus loin) sans quoi, le programme s'arrete sur une erreur d'indirection.

<li><font color="#FF0000">Imm&eacute;diat</font> : Est indiqu&eacute; par un signe <font color="#FF0000">#</font> avant l'argument. Indique une valeur num&eacute;rique, sans r&eacute;f&eacute;rence d'adresse. Donc #3 est la valeur num&eacute;rique 3.
</ol>

<p>
Un programme est constitu&eacute; d'une suite d'instructions contigues en m&eacute;moire. Chaque instruction occupant une case m&eacute;moire. Apr&egrave;s l'ex&eacute;cution d'une instruction, la suiavnte dans la m&eacute;moire est ex&eacute;cut&eacute;e (sauf si l'instruction est une instruction de saut). Les instructions sont au nombre de 9 :

<ul>
<li><font color="#FF0000">DAT A</font> : C'est une d&eacute;claration de donn&eacute;e. DAT 5 repr&eacute;sente la valeur 5. Cette instruction n'est pas ex&eacute;cutable (si un programme doit l'ex&eacute;cuter, il est arret&eacute;). Elle ne comporte qu'un seul argument (la valeur) qui n'a pas de type (ni relatif, ni indirect ni imm&eacute;diat).

<li><font color="#FF0000">MOV A B</font> : Copie la case m&eacute;moire d'adresse A vers la case d'adresse B. Par exemple, MOV 0 1 copie l'adresse relative 0 (donc la case en cours d'ex&eacute;cution, soit l'instruction MOV 0 1 elle meme) vers la case suivante (la prochaine ex&eacute;cut&eacute;e). Cette seule instruction constitue un programme tr&egrave;s court qui se recopie ind&eacute;finiment en m&eacute;moire. Son premier argument peut etre de tout type (relatif, indirect ou imm&eacute;diat) alors que son second ne peut etre que relatif ou indirect.

<li><font color="#FF0000">ADD A B</font> : Ajoute le contenu de la case d'adresse A vers la case d'adresse B. Son premier argument A peut etre de tout type (relatif, indirect ou imm&eacute;diat) alors que le second, B, ne peut etre que relatif ou indirect. Cependant, les cases point&eacute;es doivent etre du type DAT car on ne peut ajouter que des valeurs num&eacute;riques entre elles (on ne peut ajouter une valeur &agrave; une instruction ou inversement). Si ce n'est pas le cas, le programme s'arrete sur une erreur arithm&eacute;tique.

<li><font color="#FF0000">JMP A</font> : Saut &agrave; l'adresse A. La prochaine instruction ex&eacute;cut&eacute;e le sera &agrave; cette adresse. L'argument A peut etre relatif ou indirect, mais pas imm&eacute;diat.

<li><font color="#FF0000">JMZ A B</font> : Saut &agrave; l'adresse A si le contenu de B est nul. Les arguments A et B doivent etre relatifs ou indirects, mais pas imm&eacute;diat.

<li><font color="#FF0000">JMG A B</font> : Saut &agrave; l'adresse A si le contenu de B est sup&eacute;rieur &agrave; z&eacute;ro. Les arguments A et B doivent etre relatifs ou indirects, mais pas imm&eacute;diat.

<li><font color="#FF0000">DJZ A B</font> : D&eacute;cr&eacute;mente (soustrait 1) le contenu de A saut &agrave; la case B si le r&eacute;sultat est z&eacute;ro. Les arguments A et B doivent etre relatifs ou indirects, mais pas imm&eacute;diat.

<li><font color="#FF0000">CMP A B</font> : Comparaison de A et B et saut de l'instruction suivante s'ils sont diff&eacute;rents. Les arguments peuvent etre de tous type.
</ul>

<p>
Voici un tableau r&eacute;capitulatif des instructions de Red Code :
</p>

<table boder=2 cellpadding=10 cellspacing=1>
<tr bgcolor="#808080">
<td>Instruction</td>
<td>argument A</td>
<td>argument B</td>
<td>description</td>
</tr>

<tr bgcolor="#606060">
<td>DAT</td>
<td>?</td>
<td>-</td>
<td>Donn&eacute;e</td>
</tr>

<tr bgcolor="#707070">
<td>MOV</td>
<td>relatif, indirect, imm&eacute;diat</td>
<td>relatif, indirect</td>
<td>Recopie le contenu de A vers B</td>
</tr>

<tr bgcolor="#606060">
<td>ADD</td>
<td>relatif, indirect, imm&eacute;diat</td>
<td>relatif, indirect</td>
<td>Ajoute le contenu de A dans B</td>
</tr>

<tr bgcolor="#707070">
<td>SUB</td>
<td>relatif, indirect, imm&eacute;diat</td>
<td>relatif, indirect</td>
<td>Soustrait le contenu de A &agrave; B</td>
</tr>

<tr bgcolor="#606060">
<td>JMP</td>
<td>relatif, indirect</td>
<td>-</td>
<td>Saute &agrave; l'adresse A</td>
</tr>

<tr bgcolor="#707070">
<td>JMZ</td>
<td>relatif, indirect</td>
<td>relatif, indirect</td>
<td>Saute vers A si B est nul</td>
</tr>

<tr bgcolor="#606060">
<td>JMG</td>
<td>relatif, indirect</td>
<td>relatif, indirect</td>
<td>Saute vers A si B est sup&eacute;rieur &agrave; 0</td>
</tr>

<tr bgcolor="#707070">
<td>DJZ</td>
<td>relatif, indirect</td>
<td>relatif, indirect</td>
<td>D&eacute;cr&eacute;mente B et saute vers A si le r&eacute;sultat est nul</td>
</tr>

<tr bgcolor="#606060">
<td>CMP</td>
<td>relatif, indirect, imm&eacute;diat</td>
<td>relatif, indirect, imm&eacute;diat</td>
<td>D&eacute;cr&eacute;mente B et saute vers A si le r&eacute;sultat est nul</td>
</tr>
</table>
</font>

<p>
<font color="#FF0000"><h1>Exemples de programmes :</h1></font>

<p>
Un exemple vallant mieux qu'un long discours, voici quelques programmes simples permettant de se faire une id&eacute;e plus claire du langage Red Code :

<p>
<font color="#FF0000" size=+1>IMP</font>

<p>
IMP est un programme tr&egrave;s simple, il ne comporte qu'une seule instruction !

<pre>
  MOV  0  1
</pre>

<p>
Il se recopie &agrave; la case m&eacute;moire suivante qui est ex&eacute;cut&eacute;e apr&egrave;s cette instruction. On obtient donc un programme autor&eacute;pliquant tr&egrave;s simple qui se comporte comme un rouleau compresseur et qui &eacute;crase toutes les cases m&eacute;moire de la m&eacute;moire. Cependant ce programme est tr&egrave;s primaire et ne peut pour ainsi dire pas planter son adversaire dans la mesure o&ugrave; si son adversaire est amen&eacute; &agrave; ex&eacute;cuter une de ses instructions, il se transforme lui meme en IMP !

<p>
<font color="#FF0000" size=+1>DWARF</font>

<p>
Ce programme (comme le pr&eacute;c&eacute;dent d'ailleurs) a &eacute;t&eacute; propos&eacute; par Dewdney dans son premier article sur Core War (il est donc en quelque sorte d'int&eacute;ret historique). Il est aussi tr&egrave;s simple, mais toutefois plus efficace que le pr&eacute;c&eacute;dent, dans la mesure ou il peut effectivement planter l'adversaire.

<pre>
  JMP  2
  DAT  -1
  ADD  #5  -1
  MOV  #0  @-2
  JMP  -2
</pre>

<p>
Ce programme est une sorte de bombardier : il boucle ind&eacute;finiment et bombarde une case de la m&eacute;moire avec un DAT 0 (pour planter un programme qui serait amen&eacute; &agrave; ex&eacute;cuter cette instruction) &agrave; chaque it&eacute;ration. L'adresse est incr&eacute;ment&eacute;e &agrave; chaque boucle de 5 cases (ADD #5 -1) de mani&egrave;re &agrave; balayer la m&eacute;moire. DAT -1 est le compteur de l'adresse de la case vis&eacute;e par le projectile, l'instruction MOV #0 @-2 y fait r&eacute;f&eacute;rence comme adresse de destination.

<p>
<font color="#FF0000" size=+1>GEMINI</font>

<p>
Ce programme est aussi un exemple tir&eacute; du premier article de Dewdney. Son int&eacute;ret est qu'il se reproduit (de mani&egrave;re plus efficace que IMP). Il doit etre vu comme une partie de code d'un programme plus vaste (qui comporterait entre autre une fonction vraiment offensive) ayant la possibilit&eacute; de se reproduire en m&eacute;moire.

<pre>
  jmp  3
  dat  0
  dat  99
  mov  @-2 @-1
  cmp  -3  #9
  jmp  4
  add  #1  -5
  add  #1  -5
  jmp  -5
  mov  #99 93
  jmp  93
</pre>

<p>
Dans un premier temps, il se reproduit par copie des cases m&eacute;moire de son propre code, puis il saute &agrave; sa copie.

<p>
Le plus simple pour &eacute;tudier ces programmes est de les charger dans le moteur de Core Warrior et de les ex&eacute;cuter pas &agrave; pas pour voir l'effet de chaque instruction.

<p>
Vous en savez maintenant assez pour cr&eacute;er vos premiers guerriers ! Pour ce faire, je ne saurait que vous recommander d'installer et lancer l'&eacute;diteur de Core Warrior (lanc&eacute; par le script moteur ou moteur.bat).

<br>
<hr>
<address><a href="mailto:casa@sdv.fr">Michel CASABIANCA</a></address>
<!-- Created: Sun Nov 29 02:22:46 CET 1998 -->
<!-- hhmts start -->
Last modified: Sun Nov 29 22:46:45 CET 1998
<!-- hhmts end -->
</body>
</html>
